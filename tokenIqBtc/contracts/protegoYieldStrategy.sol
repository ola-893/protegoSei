// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/interfaces/IERC4626.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "./masterVault.sol";

/**
 * @title ProtegoYieldStrategy
 * @dev Enhanced automated yield generation strategy for Sei Network with GOAT integration
 * Now serves as a monitoring and coordination layer for GOAT's external yield generation
 */
contract ProtegoYieldStrategy is Ownable, ReentrancyGuard, AccessControl {
    using SafeMath for uint256;
    
    /// @dev Role definitions
    bytes32 public constant GOAT_EXECUTOR_ROLE = keccak256("GOAT_EXECUTOR_ROLE");
    bytes32 public constant STRATEGY_MANAGER_ROLE = keccak256("STRATEGY_MANAGER_ROLE");
    
    /// @dev Payment token for yield generation
    IERC20 public immutable paymentToken;
    
    /// @dev Master vault contract
    ProtegoMasterVault public immutable masterVault;
    
    /// @dev Base yield rate in basis points (annual)
    uint256 public baseYieldRateBps = 800; // 8% annual
    
    /// @dev Yield multiplier for Sei Network efficiency
    uint256 public seiMultiplier = 150; // 1.5x multiplier due to Sei's speed
    
    /// @dev Cross-chain yield multiplier
    uint256 public crossChainMultiplier = 200; // 2x multiplier for cross-chain opportunities
    
    /// @dev Last yield generation timestamp
    uint256 public lastYieldGeneration;
    
    /// @dev Total yield generated by strategy
    uint256 public totalYieldGenerated;
    
    /// @dev GOAT agent address
    address public goatAgent;
    
    /// @dev Strategy configuration
    struct StrategyConfig {
        uint256 liquidityPoolAllocation;  // % allocated to liquidity pools
        uint256 lendingProtocolAllocation; // % allocated to lending
        uint256 stakingAllocation;        // % allocated to staking
        uint256 crossChainAllocation;     // % allocated to cross-chain opportunities
        uint256 reserveAllocation;        // % kept as reserve
    }
    
    StrategyConfig public strategyConfig = StrategyConfig({
        liquidityPoolAllocation: 30,  // 30%
        lendingProtocolAllocation: 25, // 25%
        stakingAllocation: 15,        // 15%
        crossChainAllocation: 25,     // 25%
        reserveAllocation: 5          // 5%
    });
    
    /// @dev Track GOAT's performance metrics
    struct GoatPerformance {
        uint256 totalDeployments;
        uint256 totalReturns;
        uint256 totalYieldGenerated;
        uint256 averageYieldRate;
        uint256 successfulSessions;
        uint256 failedSessions;
        uint256 lastUpdateTime;
    }
    
    GoatPerformance public goatPerformance;
    
    event YieldGenerated(
        uint256 totalAmount,
        uint256 vaultCount,
        uint256 effectiveAPY,
        uint256 timestamp
    );
    
    event StrategyConfigUpdated(
        uint256 liquidityPool,
        uint256 lending,
        uint256 staking,
        uint256 crossChain,
        uint256 reserve
    );
    
    event GoatPerformanceUpdated(
        uint256 totalDeployments,
        uint256 totalReturns,
        uint256 averageYieldRate,
        uint256 timestamp
    );
    
    constructor(
        address paymentToken_,
        address masterVault_
    ) {
        require(paymentToken_ != address(0), "Invalid payment token");
        require(masterVault_ != address(0), "Invalid master vault");
        
        paymentToken = IERC20(paymentToken_);
        masterVault = ProtegoMasterVault(masterVault_);
        lastYieldGeneration = block.timestamp;
        
        // Setup roles
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(GOAT_EXECUTOR_ROLE, msg.sender);
        _grantRole(STRATEGY_MANAGER_ROLE, msg.sender);
    }
    
    /**
     * @dev Sets the GOAT agent address
     */
    function setGoatAgent(address goatAgent_) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(goatAgent_ != address(0), "Invalid GOAT agent");
        
        if (goatAgent != address(0)) {
            _revokeRole(GOAT_EXECUTOR_ROLE, goatAgent);
            _revokeRole(STRATEGY_MANAGER_ROLE, goatAgent);
        }
        
        goatAgent = goatAgent_;
        _grantRole(GOAT_EXECUTOR_ROLE, goatAgent_);
        _grantRole(STRATEGY_MANAGER_ROLE, goatAgent_);
    }
    
    /**
     * @dev GOAT reports yield generation performance
     */
    function reportGoatPerformance(
        uint256 newDeployments,
        uint256 newReturns,
        uint256 newYieldGenerated,
        bool sessionSuccessful
    ) external onlyRole(GOAT_EXECUTOR_ROLE) {
        goatPerformance.totalDeployments = goatPerformance.totalDeployments.add(newDeployments);
        goatPerformance.totalReturns = goatPerformance.totalReturns.add(newReturns);
        goatPerformance.totalYieldGenerated = goatPerformance.totalYieldGenerated.add(newYieldGenerated);
        
        if (sessionSuccessful) {
            goatPerformance.successfulSessions++;
        } else {
            goatPerformance.failedSessions++;
        }
        
        // Calculate average yield rate
        if (goatPerformance.totalDeployments > 0) {
            goatPerformance.averageYieldRate = goatPerformance.totalYieldGenerated
                .mul(10000)
                .div(goatPerformance.totalDeployments);
        }
        
        goatPerformance.lastUpdateTime = block.timestamp;
        
        emit GoatPerformanceUpdated(
            goatPerformance.totalDeployments,
            goatPerformance.totalReturns,
            goatPerformance.averageYieldRate,
            block.timestamp
        );
    }
    
    /**
     * @dev Executes yield generation strategy across all active vaults (legacy function)
     */
    function executeYieldStrategy() external onlyRole(STRATEGY_MANAGER_ROLE) {
        address[] memory vaults = masterVault.getAllVaults();
        require(vaults.length > 0, "No vaults to process");
        
        uint256[] memory yieldAmounts = new uint256[](vaults.length);
        uint256 totalYield = 0;
        
        // Calculate time elapsed since last yield generation
        uint256 timeElapsed = block.timestamp - lastYieldGeneration;
        uint256 periodsElapsed = timeElapsed.div(30 days); // Monthly periods
        
        if (periodsElapsed == 0) {
            periodsElapsed = 1; // Minimum one period for demonstration
        }
        
        // Generate yield for each vault
        for (uint256 i = 0; i < vaults.length; i++) {
            ProtegoYieldVault vault = ProtegoYieldVault(vaults[i]);
            uint256 vaultAssets = vault.totalAssets();
            
            if (vaultAssets > 0) {
                // Calculate yield based on Sei-optimized strategy
                uint256 baseYield = vaultAssets
                    .mul(baseYieldRateBps)
                    .mul(periodsElapsed)
                    .div(10000)
                    .div(12); // Monthly yield
                
                // Apply Sei speed multiplier and cross-chain opportunities
                uint256 yieldAmount = baseYield
                    .mul(seiMultiplier)
                    .div(100)
                    .mul(crossChainMultiplier)
                    .div(100);
                
                yieldAmounts[i] = yieldAmount;
                totalYield = totalYield.add(yieldAmount);
            }
        }
        
        if (totalYield > 0) {
            // Mint yield tokens to this contract
            require(
                paymentToken.transferFrom(owner(), address(this), totalYield),
                "Yield funding failed"
            );
            
            // Approve master vault to distribute yield
            require(
                paymentToken.approve(address(masterVault), totalYield),
                "Yield approval failed"
            );
            
            // Execute batch yield distribution
            masterVault.batchGenerateYield(vaults, yieldAmounts);
            
            totalYieldGenerated = totalYieldGenerated.add(totalYield);
            lastYieldGeneration = block.timestamp;
            
            // Calculate effective APY
            uint256 effectiveAPY = baseYieldRateBps
                .mul(seiMultiplier)
                .div(100)
                .mul(crossChainMultiplier)
                .div(100);
            
            emit YieldGenerated(totalYield, vaults.length, effectiveAPY, block.timestamp);
        }
    }
    
    /**
     * @dev Updates yield strategy configuration
     */
    function updateStrategyConfig(
        uint256 liquidityPool,
        uint256 lending,
        uint256 staking,
        uint256 crossChain,
        uint256 reserve
    ) external onlyRole(STRATEGY_MANAGER_ROLE) {
        require(
            liquidityPool.add(lending).add(staking).add(crossChain).add(reserve) == 100,
            "Allocations must sum to 100%"
        );
        
        strategyConfig = StrategyConfig({
            liquidityPoolAllocation: liquidityPool,
            lendingProtocolAllocation: lending,
            stakingAllocation: staking,
            crossChainAllocation: crossChain,
            reserveAllocation: reserve
        });
        
        emit StrategyConfigUpdated(liquidityPool, lending, staking, crossChain, reserve);
    }
    
    /**
     * @dev Updates base yield rate
     */
    function setBaseYieldRate(uint256 newRateBps) external onlyRole(STRATEGY_MANAGER_ROLE) {
        require(newRateBps <= 5000, "Rate too high"); // Max 50% annual
        baseYieldRateBps = newRateBps;
    }
    
    /**
     * @dev Updates Sei multiplier
     */
    function setSeiMultiplier(uint256 newMultiplier) external onlyRole(STRATEGY_MANAGER_ROLE) {
        require(newMultiplier >= 100 && newMultiplier <= 300, "Invalid multiplier");
        seiMultiplier = newMultiplier;
    }
    
    /**
     * @dev Updates cross-chain multiplier
     */
    function setCrossChainMultiplier(uint256 newMultiplier) external onlyRole(STRATEGY_MANAGER_ROLE) {
        require(newMultiplier >= 100 && newMultiplier <= 500, "Invalid cross-chain multiplier");
        crossChainMultiplier = newMultiplier;
    }
    
    /**
     * @dev Get GOAT performance metrics
     */
    function getGoatPerformance() external view returns (GoatPerformance memory) {
        return goatPerformance;
    }
    
    /**
     * @dev Calculate optimal yield rate based on current market conditions (GOAT helper)
     */
    function calculateOptimalYieldRate() external view returns (uint256 optimalRate) {
        // Base calculation considering current performance
        optimalRate = baseYieldRateBps;
        
        // Adjust based on GOAT performance
        if (goatPerformance.averageYieldRate > baseYieldRateBps) {
            // GOAT is performing better than base rate
            optimalRate = goatPerformance.averageYieldRate;
        }
        
        // Apply multipliers
        optimalRate = optimalRate.mul(seiMultiplier).div(100);
        
        // Consider cross-chain opportunities
        if (strategyConfig.crossChainAllocation > 0) {
            uint256 crossChainBonus = optimalRate
                .mul(crossChainMultiplier.sub(100))
                .div(100)
                .mul(strategyConfig.crossChainAllocation)
                .div(100);
            optimalRate = optimalRate.add(crossChainBonus);
        }
        
        return optimalRate;
    }
    
    /**
     * @dev Emergency function to pause yield generation
     */
    function emergencyPause() external onlyRole(DEFAULT_ADMIN_ROLE) {
        // Trigger global emergency in master vault
        masterVault.globalEmergencyWithdraw();
    }
}


