// // SPDX-License-Identifier: MIT
// pragma solidity ^0.8.19;

// import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
// import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
// import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
// import "@openzeppelin/contracts/interfaces/IERC4626.sol";
// import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
// import "@openzeppelin/contracts/access/Ownable.sol";
// import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
// import "@openzeppelin/contracts/utils/math/SafeMath.sol";
// import "@openzeppelin/contracts/utils/math/Math.sol";
// import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
// import "@openzeppelin/contracts/access/AccessControl.sol";
// import "./masterVault.sol";

// /**
//  * @title ProtegoYieldStrategy
//  * @dev Enhanced automated yield generation strategy for Sei Network with GOAT integration
//  * Now serves as a monitoring and coordination layer for GOAT's external yield generation
//  */
// contract ProtegoYieldStrategy is Ownable, ReentrancyGuard, AccessControl {
//     using SafeMath for uint256;
    
//     /// @dev Role definitions
//     bytes32 public constant GOAT_EXECUTOR_ROLE = keccak256("GOAT_EXECUTOR_ROLE");
//     bytes32 public constant STRATEGY_MANAGER_ROLE = keccak256("STRATEGY_MANAGER_ROLE");
    
//     /// @dev Payment token for yield generation
//     IERC20 public immutable paymentToken;
    
//     /// @dev Master vault contract
//     ProtegoMasterVault public immutable masterVault;
    
//     /// @dev Base yield rate in basis points (annual)
//     uint256 public baseYieldRateBps = 800; // 8% annual
    
//     /// @dev Yield multiplier for Sei Network efficiency
//     uint256 public seiMultiplier = 150; // 1.5x multiplier due to Sei's speed
    
//     /// @dev Cross-chain yield multiplier
//     uint256 public crossChainMultiplier = 200; // 2x multiplier for cross-chain opportunities
    
//     /// @dev Last yield generation timestamp
//     uint256 public lastYieldGeneration;
    
//     /// @dev Total yield generated by strategy
//     uint256 public totalYieldGenerated;
    
//     /// @dev GOAT agent address
//     address public goatAgent;
    
//     /// @dev Strategy configuration
//     struct StrategyConfig {
//         uint256 liquidityPoolAllocation;  // % allocated to liquidity pools
//         uint256 lendingProtocolAllocation; // % allocated to lending
//         uint256 stakingAllocation;        // % allocated to staking
//         uint256 crossChainAllocation;     // % allocated to cross-chain opportunities
//         uint256 reserveAllocation;        // % kept as reserve
//     }
    
//     StrategyConfig public strategyConfig = StrategyConfig({
//         liquidityPoolAllocation: 30,  // 30%
//         lendingProtocolAllocation: 25, // 25%
//         stakingAllocation: 15,        // 15%
//         crossChainAllocation: 25,     // 25%
//         reserveAllocation: 5          // 5%
//     });
    
//     /// @dev Track GOAT's performance metrics
//     struct GoatPerformance {
//         uint256 totalDeployments;
//         uint256 totalReturns;
//         uint256 totalYieldGenerated;
//         uint256 averageYieldRate;
//         uint256 successfulSessions;
//         uint256 failedSessions;
//         uint256 lastUpdateTime;
//     }
    
//     GoatPerformance public goatPerformance;
    
//     event YieldGenerated(
//         uint256 totalAmount,
//         uint256 vaultCount,
//         uint256 effectiveAPY,
//         uint256 timestamp
//     );
    
//     event StrategyConfigUpdated(
//         uint256 liquidityPool,
//         uint256 lending,
//         uint256 staking,
//         uint256 crossChain,
//         uint256 reserve
//     );
    
//     event GoatPerformanceUpdated(
//         uint256 totalDeployments,
//         uint256 totalReturns,
//         uint256 averageYieldRate,
//         uint256 timestamp
//     );
    
//     constructor(
//         address paymentToken_,
//         address masterVault_
//     ) {
//         require(paymentToken_ != address(0), "Invalid payment token");
//         require(masterVault_ != address(0), "Invalid master vault");
        
//         paymentToken = IERC20(paymentToken_);
//         masterVault = ProtegoMasterVault(masterVault_);
//         lastYieldGeneration = block.timestamp;
        
//         // Setup roles
//         _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
//         _grantRole(GOAT_EXECUTOR_ROLE, msg.sender);
//         _grantRole(STRATEGY_MANAGER_ROLE, msg.sender);
//     }
    
//     /**
//      * @dev Sets the GOAT agent address
//      */
//     function setGoatAgent(address goatAgent_) external onlyRole(DEFAULT_ADMIN_ROLE) {
//         require(goatAgent_ != address(0), "Invalid GOAT agent");
        
//         if (goatAgent != address(0)) {
//             _revokeRole(GOAT_EXECUTOR_ROLE, goatAgent);
//             _revokeRole(STRATEGY_MANAGER_ROLE, goatAgent);
//         }
        
//         goatAgent = goatAgent_;
//         _grantRole(GOAT_EXECUTOR_ROLE, goatAgent_);
//         _grantRole(STRATEGY_MANAGER_ROLE, goatAgent_);
//     }
    
//     /**
//      * @dev GOAT reports yield generation performance
//      */
//     function reportGoatPerformance(
//         uint256 newDeployments,
//         uint256 newReturns,
//         uint256 newYieldGenerated,
//         bool sessionSuccessful
//     ) external onlyRole(GOAT_EXECUTOR_ROLE) {
//         goatPerformance.totalDeployments = goatPerformance.totalDeployments.add(newDeployments);
//         goatPerformance.totalReturns = goatPerformance.totalReturns.add(newReturns);
//         goatPerformance.totalYieldGenerated = goatPerformance.totalYieldGenerated.add(newYieldGenerated);
        
//         if (sessionSuccessful) {
//             goatPerformance.successfulSessions++;
//         } else {
//             goatPerformance.failedSessions++;
//         }
        
//         // Calculate average yield rate
//         if (goatPerformance.totalDeployments > 0) {
//             goatPerformance.averageYieldRate = goatPerformance.totalYieldGenerated
//                 .mul(10000)
//                 .div(goatPerformance.totalDeployments);
//         }
        
//         goatPerformance.lastUpdateTime = block.timestamp;
        
//         emit GoatPerformanceUpdated(
//             goatPerformance.totalDeployments,
//             goatPerformance.totalReturns,
//             goatPerformance.averageYieldRate,
//             block.timestamp
//         );
//     }
    
//     /**
//      * @dev Executes yield generation strategy across all active vaults (legacy function)
//      */
//     function executeYieldStrategy() external onlyRole(STRATEGY_MANAGER_ROLE) {
//         address[] memory vaults = masterVault.getAllVaults();
//         require(vaults.length > 0, "No vaults to process");
        
//         uint256[] memory yieldAmounts = new uint256[](vaults.length);
//         uint256 totalYield = 0;
        
//         // Calculate time elapsed since last yield generation
//         uint256 timeElapsed = block.timestamp - lastYieldGeneration;
//         uint256 periodsElapsed = timeElapsed.div(30 days); // Monthly periods
        
//         if (periodsElapsed == 0) {
//             periodsElapsed = 1; // Minimum one period for demonstration
//         }
        
//         // Generate yield for each vault
//         for (uint256 i = 0; i < vaults.length; i++) {
//             ProtegoYieldVault vault = ProtegoYieldVault(vaults[i]);
//             uint256 vaultAssets = vault.totalAssets();
            
//             if (vaultAssets > 0) {
//                 // Calculate yield based on Sei-optimized strategy
//                 uint256 baseYield = vaultAssets
//                     .mul(baseYieldRateBps)
//                     .mul(periodsElapsed)
//                     .div(10000)
//                     .div(12); // Monthly yield
                
//                 // Apply Sei speed multiplier and cross-chain opportunities
//                 uint256 yieldAmount = baseYield
//                     .mul(seiMultiplier)
//                     .div(100)
//                     .mul(crossChainMultiplier)
//                     .div(100);
                
//                 yieldAmounts[i] = yieldAmount;
//                 totalYield = totalYield.add(yieldAmount);
//             }
//         }
        
//         if (totalYield > 0) {
//             // Mint yield tokens to this contract
//             require(
//                 paymentToken.transferFrom(owner(), address(this), totalYield),
//                 "Yield funding failed"
//             );
            
//             // Approve master vault to distribute yield
//             require(
//                 paymentToken.approve(address(masterVault), totalYield),
//                 "Yield approval failed"
//             );
            
//             // Execute batch yield distribution
//             masterVault.batchGenerateYield(vaults, yieldAmounts);
            
//             totalYieldGenerated = totalYieldGenerated.add(totalYield);
//             lastYieldGeneration = block.timestamp;
            
//             // Calculate effective APY
//             uint256 effectiveAPY = baseYieldRateBps
//                 .mul(seiMultiplier)
//                 .div(100)
//                 .mul(crossChainMultiplier)
//                 .div(100);
            
//             emit YieldGenerated(totalYield, vaults.length, effectiveAPY, block.timestamp);
//         }
//     }
    
//     /**
//      * @dev Updates yield strategy configuration
//      */
//     function updateStrategyConfig(
//         uint256 liquidityPool,
//         uint256 lending,
//         uint256 staking,
//         uint256 crossChain,
//         uint256 reserve
//     ) external onlyRole(STRATEGY_MANAGER_ROLE) {
//         require(
//             liquidityPool.add(lending).add(staking).add(crossChain).add(reserve) == 100,
//             "Allocations must sum to 100%"
//         );
        
//         strategyConfig = StrategyConfig({
//             liquidityPoolAllocation: liquidityPool,
//             lendingProtocolAllocation: lending,
//             stakingAllocation: staking,
//             crossChainAllocation: crossChain,
//             reserveAllocation: reserve
//         });
        
//         emit StrategyConfigUpdated(liquidityPool, lending, staking, crossChain, reserve);
//     }
    
//     /**
//      * @dev Updates base yield rate
//      */
//     function setBaseYieldRate(uint256 newRateBps) external onlyRole(STRATEGY_MANAGER_ROLE) {
//         require(newRateBps <= 5000, "Rate too high"); // Max 50% annual
//         baseYieldRateBps = newRateBps;
//     }
    
//     /**
//      * @dev Updates Sei multiplier
//      */
//     function setSeiMultiplier(uint256 newMultiplier) external onlyRole(STRATEGY_MANAGER_ROLE) {
//         require(newMultiplier >= 100 && newMultiplier <= 300, "Invalid multiplier");
//         seiMultiplier = newMultiplier;
//     }
    
//     /**
//      * @dev Updates cross-chain multiplier
//      */
//     function setCrossChainMultiplier(uint256 newMultiplier) external onlyRole(STRATEGY_MANAGER_ROLE) {
//         require(newMultiplier >= 100 && newMultiplier <= 500, "Invalid cross-chain multiplier");
//         crossChainMultiplier = newMultiplier;
//     }
    
//     /**
//      * @dev Get GOAT performance metrics
//      */
//     function getGoatPerformance() external view returns (GoatPerformance memory) {
//         return goatPerformance;
//     }
    
//     /**
//      * @dev Calculate optimal yield rate based on current market conditions (GOAT helper)
//      */
//     function calculateOptimalYieldRate() external view returns (uint256 optimalRate) {
//         // Base calculation considering current performance
//         optimalRate = baseYieldRateBps;
        
//         // Adjust based on GOAT performance
//         if (goatPerformance.averageYieldRate > baseYieldRateBps) {
//             // GOAT is performing better than base rate
//             optimalRate = goatPerformance.averageYieldRate;
//         }
        
//         // Apply multipliers
//         optimalRate = optimalRate.mul(seiMultiplier).div(100);
        
//         // Consider cross-chain opportunities
//         if (strategyConfig.crossChainAllocation > 0) {
//             uint256 crossChainBonus = optimalRate
//                 .mul(crossChainMultiplier.sub(100))
//                 .div(100)
//                 .mul(strategyConfig.crossChainAllocation)
//                 .div(100);
//             optimalRate = optimalRate.add(crossChainBonus);
//         }
        
//         return optimalRate;
//     }
    
//     /**
//      * @dev Emergency function to pause yield generation
//      */
//     function emergencyPause() external onlyRole(DEFAULT_ADMIN_ROLE) {
//         // Trigger global emergency in master vault
//         masterVault.globalEmergencyWithdraw();
//     }
// }


